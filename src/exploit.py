import asyncio
import os
from typing import Sequence

from src.util import acquire_user_initials_or_exit, ainput, setup_signal_handlers, send_upd_message, periodic
from src.data import State, Transaction, TransactionIntent
from src.main import send_synchronization_pulse, broadcast, extract_transaction, pack_transaction
import src.proto as Protocol


MINE_USERNAME = "77"


async def setup(host, port, state: State):
    # TODO: fix this - form commandline args, maybe add some casting - ports should be ints
    local, remote_host, remote_port, _from, to = os.args

    local_nodes = [
        (host, local),
    ]
    remote_nodes = [
        (remote_host, remote_port),
    ]

    get_from = _from
    get_to = to

    broadcast_fn = lambda msg: broadcast(local_nodes, msg)
    remote_broadcast_fn = lambda msg: broadcast(remote_nodes, msg)
    # this is a global, mutable variable, because we're in the 80's
    global BROADCAST_FN
    BROADCAST_FN = broadcast_fn

    send_synchronization_pulse(broadcast_fn)
    await asyncio.sleep(2)
    print("initial node sync complete")

    ids = []
    victim_balance = state.balance(get_from)
    ts = filter(lambda t: t.to_username == get_from, state.transactions.values())
    for i in range(victim_balance):
        t = next(ts)
        t.to_username = get_to
        t.timestamp = 0
        ids.append(t.number)
        remote_broadcast_fn(pack_transaction(t))

    for i in ids:
        remote_broadcast_fn(Protocol.GetTransaction(i))

    print("It's done, my liege")


async def process_incoming_messages(q: Sequence[Protocol.Message], state: State) -> None:
    broadcast_fn = BROADCAST_FN

    local_trn = state.highest_transaction_number

    for m in q:
        if isinstance(m, Protocol.HighestTransaction):
            pass

        elif isinstance(m, Protocol.NewTransaction):
            t = extract_transaction(m)

            if state.incorporate(t):
                pass
            else:
                pass

        elif isinstance(m, Protocol.GetTransaction):
            t = state[m.number]
            pass

        elif isinstance(m, Protocol.HighestTransactionResponse):
            network_trn = m.number
            if network_trn > local_trn:
                for i in range(max(local_trn, 0), network_trn + 1):
                    broadcast_fn(Protocol.GetTransaction(i))

    q.clear()


def main(local: int, remote_host: str, remote_port: int, _from: str, to: str):
    host = "127.0.0.1"
    port = int(os.environ["APP_PORT"])

    loop = asyncio.get_event_loop()
    setup_signal_handlers()

    # actually, is this queue needed?
    q = []
    state = State()

    class CustomProtocol(asyncio.DatagramProtocol):
        def datagram_received(self, data, addr):
            msg = Protocol.decode(data)
            q.append(msg)
            loop = asyncio.get_event_loop()
            loop.create_task(process_incoming_messages(q, state))

    t = loop.create_datagram_endpoint(CustomProtocol, local_addr=(host, port))
    loop.run_until_complete(t)

    t = loop.create_task(setup(host, port, state, local, remote_host, remote_port, _from, to))
    loop.run_until_complete(t)


if __name__ == "__main__":
    typer.run(main)
